function [P, Y, alpha, A, label, P0, B, Loss, iter] = PCBG(X,c,anchor_rate,ML,CL,gama,Iter,opts)
% Input:
%       - X: the data matrix of size n * d * nView, where each row is a sample point;
%       - c: the number of clusters;
%       - anchor_rate: the rate of sampling data points as anchors;
%       - ML: the must-link constraints;
%       - CL: the cannot-link constraints;
%       - gama: 控制不可连接约束的正则项的系数;
%       - Iter: the maximum number of iterations of External circulation;
%       - opts: options for this algorithm
%           - style: 
%               - '0': DAS;
%               - '1': VDA
%               - '2': use randomly sampled points from the original data set;
%               - '3': use the nearest point of each cluster center generated by kmeans;  
%               - '4': use centers of clusters generated by kmeans; 
%           - IterMax: the maximum number of iterations of Internal circulation;
%           - islocal: 是否局部优化
%           - w: canot-link 正则项的内参数
%           - Theorem2: 是否应用canot-link正则项的Theorem 2分情况更新yk
%           - Theorem3: 是否应用canot-link正则项的Theorem 3局部更新yk
%           - Isbreak_Loss: 是否根据Loss终止迭代
%           - Organize_CL: 是否对cannot-klink约束进行sub-group级等价转换
%           - Convergence: 收敛误差
%           - k: the nearest-neighbor number

% Output:
%       - P: the optimized graph compatible across multiple views;
%       - Y: cannot-link指示矩阵;
%       - alpha: 每个视图的权重变化，每一列代表一次权重分布;
%       - A: 锚点数据集;
%       - label: the cluster assignment for each point;
%       - P0:  the must-link indicating bipartite graph;
%       - B: Modified bipartite graph;
%       - Loss: 损失函数;
%       - iter: 内外循环的平均迭代次数;

if ~exist('gama','var')
    gama=0.5;
end
if ~exist('Iter','var')
    Iter=10;
end
[n, ~] = size(X{1});
n_View = length(X);

IterMax = 100;
islocal = 1;
w = 1;
Theorem2 = 1;
Theorem3 = 1;
Organize_CL = 1;
Isbreak_Loss = 1;
Convergence = 1e-4;
if ~exist('opts','var')
   opts = [];
end
if isfield(opts, 'IterMax');   IterMax = opts. IterMax;  end
if isfield(opts, 'islocal');    islocal = opts. islocal;   end
if isfield(opts, 'w');    w = opts. w;   end
if isfield(opts, 'Organize_CL');  Organize_CL = opts. Organize_CL;  end
if isfield(opts, 'Theorem2');  Theorem2 = opts. Theorem2;  end
if isfield(opts, 'Theorem3');  Theorem3 = opts. Theorem3;  end
if isfield(opts, 'Isbreak_Loss');  Isbreak_Loss = opts. Isbreak_Loss;  end
if isfield(opts, 'Convergence');   Convergence = opts. Convergence;  end
if isfield(opts, 'k');  k = opts. k;  end
if isfield(opts, 'style');  style = opts. style;  end

m = fix(n*anchor_rate);
A = cell(n_View,1);
%%
% 对成对约束信息进行整理,并构建must-link指示图P0
% disp('----Construction of must-link indicating bipartite graph----');
[~, ML_g, t, CL_O, ~, ~] = Organize_PCsYU(ML, CL);
P0 = zeros(n,t);
for i = 1:t
    idx = ML_g{i};
    P0(idx,i) = 1;
end
if Organize_CL == 1
    CL = CL_O;
end
%%
% disp('------Anchor Selection and Bipartite graph Construction------');
[~, B, ~] = BipartiteGraph_YU(X,anchor_rate,opts);
%%
% disp('----------Optimizethe comprehensive bipartite graph----------');
alpha = ones(n_View,1)./n_View;
for v = 1:n_View
    BB(:,v) = reshape(B{v},[n*m 1]);
end
AA = BB'*BB;
G = zeros(n,m);
for v = 1:n_View
    G = G+alpha(v).*B{v};
end
P = G;
Loss=[0,0,0];
% nCL = size(CL,1);
% Y = zeros(n+m+t,nCL);
for it = 1:Iter
    %% update Y
    if Theorem2 == 1
        [Y,~] = SolveY_bestYU([P0,P],CL,w,Theorem3);
        % Y = Label_propagation_edit0([P0,P],CL,w);
    else
        Y = Label_propagation_edit([P0,P],CL,w);
    end

    %% update alpha
    p = reshape(P,[n*m 1]);
    s = 2*BB'*p;
    [alpha(:,it+1), ~] = SimplexQP_acc(AA, s);
    G = zeros(n,m);
    for v = 1:n_View
        G = G+alpha(v,it+1).*B{v};
    end

    %% update P
    [newlabel,~,newP, It_int(it,1), lambda] = Optimal_integration4(G, c, P0, Y, gama, IterMax, islocal);
    if lambda <= 1
        gama = 0.5 * gama;
    end
    %% coverge condition
    if Isbreak_Loss == 1
        if it == 1
            label = newlabel;
            P = newP;
            QQ = [P0,P];
            Yn=Y(1:n,:);% Y的前n行
            Ytm=Y(n+1:end,:);% Y的后t+m行
            disty = L2_distance_1(Yn', Ytm');%n*(t+m)的距离矩阵
            Loss(it+1,2) = sum(sum((G-P).^2));
            Loss(it+1,3) = sum(sum(disty.*QQ))/2;
            Loss(it+1,1) = Loss(it+1,2) + gama*Loss(it+1,3);
        else
            newQQ = [P0,newP];
            Yn=Y(1:n,:);% Y的前n行
            Ytm=Y(n+1:end,:);% Y的后t+m行
            disty = L2_distance_1(Yn', Ytm');%n*(t+m)的距离矩阵
    
            Loss1 = sum(sum((G-P).^2));
            newLoss1 = sum(sum((G-newP).^2));
            Loss2 = sum(sum(disty.*QQ))/2;
            newLoss2 = sum(sum(disty.*newQQ))/2;
            Loss_total = Loss1 + gama*Loss2;
            newLoss_total = newLoss1 + gama*newLoss2;
            if Loss_total <= newLoss_total
                Loss(it+1,2) = Loss1;
                Loss(it+1,3) = Loss2;
                Loss(it+1,1) = Loss_total;
            else
                P = newP;
                label = newlabel;
                QQ = newQQ;
                Loss(it+1,2) = newLoss1;
                Loss(it+1,3) = newLoss2;
                Loss(it+1,1) = newLoss_total;
            end
            % Loss(it+1,1) = sum(sum((G-P).^2))+gama*sum(sum(disty.*QQ));
            if abs(Loss(it+1,1) - Loss(it,1)) <= Convergence
                break
            end
        end
    else
        label = newlabel;
        P = newP;
    end
end
i = mean(It_int);
fprintf('=========================PCBG: Iter of Internal circulation = %d ==================>>>>>>\n', i);
fprintf('=========================PCBG: Iter of External circulation = %d ==================>>>>>>\n', it);
iter = [it,i];
end
